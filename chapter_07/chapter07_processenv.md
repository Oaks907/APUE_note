[TOC]

## 进程环境

### 1.**在 Intel x86 系统上，使用 Linux ，如果执行一个输出 “hello, world” 的程序但不调用 exit 或 return ，则程序的返回代码为 13 （用 shell 检查），解释其原因。**

三种情况可以导致返回的代码不为0：

* 调用这些函数时没有带终止状态
* main执行了一个无返回值的return语句
* main没有声明返回类型为整型，则该进程的终止状态是未定义的

如果 main 函数返回值为 int 的话，那么无论如何返回的都是 0 ；如果 main 函数返回值为 void 的话，那么将会返回 printf 的返回值，也就是输出的字符个数 13 。

### 2. **图 7-3 中的 printf 函数的结果何时才被真正输出。**

* 当程序处于交互运行方式时，标准输出通常处于行缓冲方式，所以当输出换行符时，上次的结果才被真正输出。

* 如果标准输出被定向到一个文件，而标准输出处于全缓冲方式，则当标准 I/O 清理操作执行时，结果才真正被输出。

### 3. **是否有方法不适用（a）参数传递、（b）全局变量这两种方法，将 main 中的参数 argc 和argv 传递给它所调用的其他函数？**

没有

### 4. **在有些 UNIX 系统实现中执行程序时访问不到其数据段的 0 单元，这是一种有意的安排，为什么？**

当C程序解引用一个空指针出错时，执行该程序的进程将终止。可以利用这种方式终止进程。

### 5. **用 C 语言的 typedef 为终止处理程序定义了一个新的数据类型 Exitfunc ，使用该类型修改 atexit 的原型。**

atexit 的原型：

```c
#include <stdlib.h>
int atexit(void (*func)(void));
```

定义如下：

```c
typedef void Exitfunc(void);
int atexit(Exitfunc *func);
```

### 6. **如果用 calloc 分配一个 long 型的数组，数组的初始值是否为 0 ？如果用 calloc 分配一个指针数组，数组的初始值是否为空指针？**

ISO C 说明：

> - calloc，为指定数量指定长度的对象分配存储空间。该空间中的每一位（bit）都初始化为 0 。

因此数组的空间初始为0。但是ISO C并不保证0值与浮点型或空指针的值相同。 

### 7. **在 7.6 节结尾处 size 命令的输出结果中，为什么没有给出堆和栈的大小？**

只有通过exec执行一个程序时，才会分配堆和栈

### 8. **为什么 7.7 节中两个文件的大小（879443 和 8378）不等于它们各自文本和数据大小的和？**

可执行文件 a.out 包含了用于调试 core 文件的符号表信息。用 strip 命令可以删除这些信息，对两个 a.out 文件执行这条命令，它们的大小减为 798760 和 6200 字节。

### 9. **为什么 7.7 节中对于一个简单的程序，使用共享库以后其可执行文件的大小变化如此巨大？**

没有使用共享库，可执行文件的大部分都被标准I/O库所占用

### 10. **在 7.10 节中我们已经说明为什么不能将一个指针返回给一个自动变量，下面的程序是否正确？**

```c
nt f1(int val) {
  int num = 0;
  int *ptr = &num;
  if (val == 0) {
    int val;
    val = 5;
    ptr = &val;
  }
  return (*ptr + 1);
}
```

不正确，if 语句里面的 val 是一个自动变量，当离开 if 的作用域时，这个变量就不存在了。